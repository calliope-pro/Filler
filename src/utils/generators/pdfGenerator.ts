function createMinimalPDF() {
  return `%PDF-1.4
1 0 obj
<<
/Type /Catalog
/Pages 2 0 R
>>
endobj

2 0 obj
<<
/Type /Pages
/Kids [3 0 R]
/Count 1
>>
endobj

3 0 obj
<<
/Type /Page
/Parent 2 0 R
/Resources <<
/Font <<
/F1 4 0 R
>>
>>
/MediaBox [0 0 612 792]
/Contents 5 0 R
>>
endobj

4 0 obj
<<
/Type /Font
/Subtype /Type1
/BaseFont /Times-Roman
>>
endobj

5 0 obj
<<
/Length 44
>>
stream
BT
/F1 12 Tf
72 720 Td
(Generated by Fillr) Tj
ET
endstream
endobj

xref
0 6
0000000000 65535 f 
0000000010 00000 n 
0000000053 00000 n 
0000000125 00000 n 
0000000348 00000 n 
0000000441 00000 n 
trailer
<<
/Size 6
/Root 1 0 R
>>
startxref
533
%%EOF`;
}

export function generatePDF(targetSize) {
  const basePDF = createMinimalPDF();
  const baseBytes = new TextEncoder().encode(basePDF);
  
  if (baseBytes.length >= targetSize) {
    // If base PDF is already larger than target, truncate it
    const truncated = baseBytes.slice(0, targetSize);
    return new Blob([truncated], { type: 'application/pdf' });
  }
  
  const bytesNeeded = targetSize - baseBytes.length;
  
  // Create padding comments
  let padding = '';
  const comment = '% Generated by Fillr dummy file generator - ';
  const repeatCount = Math.ceil(bytesNeeded / comment.length);
  
  for (let i = 0; i < repeatCount; i++) {
    padding += comment;
  }
  
  // Trim padding to exact size needed
  padding = padding.substring(0, bytesNeeded);
  
  // Combine base PDF with padding
  const finalPDF = basePDF + padding;
  const finalBytes = new TextEncoder().encode(finalPDF);
  
  // Ensure exact size
  const result = finalBytes.slice(0, targetSize);
  
  return new Blob([result], { type: 'application/pdf' });
}