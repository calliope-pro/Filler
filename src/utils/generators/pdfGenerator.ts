function createMinimalPDF() {
  return `%PDF-1.4
1 0 obj
<<
/Type /Catalog
/Pages 2 0 R
>>
endobj

2 0 obj
<<
/Type /Pages
/Kids [3 0 R]
/Count 1
>>
endobj

3 0 obj
<<
/Type /Page
/Parent 2 0 R
/Resources <<
/Font <<
/F1 4 0 R
>>
>>
/MediaBox [0 0 612 792]
/Contents 5 0 R
>>
endobj

4 0 obj
<<
/Type /Font
/Subtype /Type1
/BaseFont /Times-Roman
>>
endobj

5 0 obj
<<
/Length 44
>>
stream
BT
/F1 12 Tf
72 720 Td
(Generated by Fillr) Tj
ET
endstream
endobj

xref
0 6
0000000000 65535 f 
0000000010 00000 n 
0000000053 00000 n 
0000000125 00000 n 
0000000348 00000 n 
0000000441 00000 n 
trailer
<<
/Size 6
/Root 1 0 R
>>
startxref
533
%%EOF`;
}

export async function generatePDF(targetSize: number, onProgress?: (progress: number) => void, signal?: AbortSignal): Promise<Blob> {
  const basePDF = createMinimalPDF();
  const baseBytes = new TextEncoder().encode(basePDF);
  
  if (baseBytes.length >= targetSize) {
    const truncated = baseBytes.slice(0, targetSize);
    return new Blob([truncated], { type: 'application/pdf' });
  }
  
  const CHUNK_SIZE = 1024 * 1024; // 1MB chunks
  const chunks: Uint8Array[] = [];
  
  // Add base PDF
  chunks.push(baseBytes);
  let totalSize = baseBytes.length;
  
  const bytesNeeded = targetSize - baseBytes.length;
  const comment = '% Generated by Fillr dummy file generator - ';
  
  let remaining = bytesNeeded;
  let processed = 0;
  
  while (remaining > 0) {
    const currentChunkSize = Math.min(remaining, CHUNK_SIZE);
    let padding = '';
    
    // Generate padding for this chunk
    while (padding.length < currentChunkSize) {
      const spaceLeft = currentChunkSize - padding.length;
      const toAdd = spaceLeft >= comment.length ? comment : comment.substring(0, spaceLeft);
      padding += toAdd;
    }
    
    const paddingBytes = new TextEncoder().encode(padding);
    chunks.push(paddingBytes.slice(0, currentChunkSize));
    
    remaining -= currentChunkSize;
    processed += currentChunkSize;
    totalSize += currentChunkSize;
    
    if (onProgress) {
      onProgress(totalSize / targetSize);
    }
    
    if (signal?.aborted) {
      throw new DOMException('Generation was aborted', 'AbortError');
    }
    await new Promise(resolve => setTimeout(resolve, 0));
  }
  
  return new Blob(chunks as BlobPart[], { type: 'application/pdf' });
}