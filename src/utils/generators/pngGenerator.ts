// CRC32 calculation for PNG chunks
function crc32(data: Uint8Array): number {
  let crc = 0xFFFFFFFF;
  const table = new Array(256);
  
  // Build CRC table
  for (let i = 0; i < 256; i++) {
    let c = i;
    for (let j = 0; j < 8; j++) {
      c = (c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1);
    }
    table[i] = c;
  }
  
  // Calculate CRC
  for (let i = 0; i < data.length; i++) {
    crc = table[(crc ^ data[i]) & 0xFF] ^ (crc >>> 8);
  }
  
  return (crc ^ 0xFFFFFFFF) >>> 0;
}

function writeUint32BE(value: number): Uint8Array {
  return new Uint8Array([
    (value >>> 24) & 0xFF,
    (value >>> 16) & 0xFF,
    (value >>> 8) & 0xFF,
    value & 0xFF
  ]);
}

function createPNGChunk(type: string, data: Uint8Array): Uint8Array {
  const typeBytes = new TextEncoder().encode(type);
  const length = data.length;
  const chunk = new Uint8Array(8 + length + 4);
  
  // Length (4 bytes)
  chunk.set(writeUint32BE(length), 0);
  
  // Type (4 bytes)  
  chunk.set(typeBytes, 4);
  
  // Data
  chunk.set(data, 8);
  
  // CRC (4 bytes) - calculate for type + data
  const crcData = new Uint8Array(4 + length);
  crcData.set(typeBytes, 0);
  crcData.set(data, 4);
  const crcValue = crc32(crcData);
  chunk.set(writeUint32BE(crcValue), 8 + length);
  
  return chunk;
}

export async function generatePNG(targetSize: number, onProgress?: (progress: number) => void, signal?: AbortSignal): Promise<Blob> {
  if (targetSize < 67) {
    // Minimum valid PNG size, return basic structure
    const pngSignature = new Uint8Array([0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A]);
    const result = new Uint8Array(targetSize);
    result.set(pngSignature.slice(0, Math.min(8, targetSize)), 0);
    return new Blob([result], { type: 'image/png' });
  }

  // PNG signature (8 bytes)
  const pngSignature = new Uint8Array([0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A]);
  
  // IHDR chunk data (13 bytes) - 1x1 transparent image
  const ihdrData = new Uint8Array([
    0x00, 0x00, 0x00, 0x01, // Width: 1
    0x00, 0x00, 0x00, 0x01, // Height: 1  
    0x08,                   // Bit depth: 8
    0x06,                   // Color type: 6 (RGBA)
    0x00,                   // Compression method: 0
    0x00,                   // Filter method: 0
    0x00                    // Interlace method: 0
  ]);
  const ihdrChunk = createPNGChunk('IHDR', ihdrData);
  
  // IDAT chunk - compressed image data for 1x1 transparent pixel
  // This is a deflate-compressed stream for RGBA(0,0,0,0) with filter byte 0
  const idatData = new Uint8Array([
    0x78, 0x9C,           // Deflate header
    0x62, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x01 // Compressed data
  ]);
  const idatChunk = createPNGChunk('IDAT', idatData);
  
  // IEND chunk (empty data)
  const iendChunk = createPNGChunk('IEND', new Uint8Array(0));
  
  // Calculate base PNG size
  const basePngSize = pngSignature.length + ihdrChunk.length + idatChunk.length + iendChunk.length;
  
  if (targetSize <= basePngSize) {
    // Construct minimal PNG up to target size
    const result = new Uint8Array(targetSize);
    let offset = 0;
    
    const parts = [pngSignature, ihdrChunk, idatChunk, iendChunk];
    for (const part of parts) {
      if (offset >= targetSize) break;
      const bytesToCopy = Math.min(part.length, targetSize - offset);
      result.set(part.slice(0, bytesToCopy), offset);
      offset += bytesToCopy;
    }
    
    return new Blob([result], { type: 'image/png' });
  }
  
  // Add tEXt chunk for padding to reach exact target size
  const paddingNeeded = targetSize - basePngSize;
  const textData = new Uint8Array(paddingNeeded);
  
  // Fill with "Comment\0Generated by Fillr" pattern
  const comment = new TextEncoder().encode('Comment\0Generated by Fillr ');
  for (let i = 0; i < paddingNeeded; i++) {
    textData[i] = comment[i % comment.length];
  }
  
  const textChunk = createPNGChunk('tEXt', textData);
  
  // If the text chunk is too big, adjust it
  const totalWithText = basePngSize + textChunk.length;
  if (totalWithText > targetSize) {
    // Reduce text data to fit exactly
    const maxTextData = targetSize - basePngSize + textData.length - textChunk.length;
    const adjustedTextData = textData.slice(0, maxTextData);
    const adjustedTextChunk = createPNGChunk('tEXt', adjustedTextData);
    
    // Construct final PNG
    const result = new Uint8Array(targetSize);
    let offset = 0;
    
    result.set(pngSignature, offset); offset += pngSignature.length;
    result.set(ihdrChunk, offset); offset += ihdrChunk.length;
    result.set(idatChunk, offset); offset += idatChunk.length;
    result.set(adjustedTextChunk, offset); offset += adjustedTextChunk.length;
    result.set(iendChunk, offset);
    
    return new Blob([result], { type: 'image/png' });
  }
  
  // Construct final PNG
  const result = new Uint8Array(targetSize);
  let offset = 0;
  
  result.set(pngSignature, offset); offset += pngSignature.length;
  result.set(ihdrChunk, offset); offset += ihdrChunk.length;
  result.set(idatChunk, offset); offset += idatChunk.length;
  result.set(textChunk, offset); offset += textChunk.length;
  result.set(iendChunk, offset);
  
  if (signal?.aborted) {
    throw new DOMException('Generation was aborted', 'AbortError');
  }
  
  if (onProgress) {
    onProgress(1);
  }
  
  return new Blob([result], { type: 'image/png' });
}